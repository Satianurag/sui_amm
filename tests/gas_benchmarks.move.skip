#[test_only]
module sui_amm::gas_benchmarks {
    use sui::test_scenario::{Self as ts};
    use sui::coin::{Self};
    use sui_amm::factory::{Self, PoolRegistry};
    use sui_amm::pool::{Self, LiquidityPool};
    use sui_amm::stable_pool::{Self, StableSwapPool};
    use sui_amm::position::{LPPosition};
    use sui_amm::fee_distributor;
    use sui::clock::{Self, Clock};
    use std::option;

    // Test coins
    struct USDC has drop {}
    struct USDT has drop {}

    const ADMIN: address = @0xAD;
    const LP1: address = @0x11;

    /// Benchmark: Pool creation (constant product)
    #[test]
    fun benchmark_create_pool() {
        let scenario = ts::begin(ADMIN);
        
        // Setup factory
        factory::test_init(ts::ctx(&mut scenario));
        
        ts::next_tx(&mut scenario, ADMIN);
        {
            let registry = ts::take_shared<PoolRegistry>(&scenario);
            
            // CREATE POOL - Main operation to benchmark
            let coin_a = coin::mint_for_testing<USDC>(200000, ts::ctx(&mut scenario));
            let coin_b = coin::mint_for_testing<USDT>(200000, ts::ctx(&mut scenario));
            let (position, refund_a, refund_b) = factory::create_pool<USDC, USDT>(
                &mut registry,
                factory::fee_tier_medium(), // 0.3%
                0, // creator_fee_percent
                coin_a,
                coin_b,
                ts::ctx(&mut scenario)
            );
            
            coin::burn_for_testing(refund_a);
            coin::burn_for_testing(refund_b);
            sui::transfer::public_transfer(position, ADMIN);
            
            ts::return_shared(registry);
        };
        
        ts::end(scenario);
        // Gas cost for pool creation can be measured via transaction effects
    }

    /// Benchmark: Pool creation (stable swap)
    #[test]
    fun benchmark_create_stable_pool() {
        let scenario = ts::begin(ADMIN);
        
        factory::test_init(ts::ctx(&mut scenario));
        
        ts::next_tx(&mut scenario, ADMIN);
        {
            let registry = ts::take_shared<PoolRegistry>(&scenario);
            
            // CREATE STABLE POOL - Main operation to benchmark
            let coin_a = coin::mint_for_testing<USDC>(200000, ts::ctx(&mut scenario));
            let coin_b = coin::mint_for_testing<USDT>(200000, ts::ctx(&mut scenario));
            let (position, refund_a, refund_b) = factory::create_stable_pool<USDC, USDT>(
                &mut registry,
                factory::fee_tier_low(), // 0.05% for stables
                500,
                coin_a,
                coin_b,
                &clock_val, ts::ctx(&mut scenario)
            );
            
            coin::burn_for_testing(refund_a);
            coin::burn_for_testing(refund_b);
            sui::transfer::public_transfer(position, ADMIN);
            
            ts::return_shared(registry);
        };
        
        ts::end(scenario);
    }

    /// Benchmark: Add initial liquidity
    #[test]
    fun benchmark_add_initial_liquidity() {
        let scenario = ts::begin(ADMIN);
        
        // Setup
        factory::test_init(ts::ctx(&mut scenario));
        
        ts::next_tx(&mut scenario, ADMIN);
        {
            let registry = ts::take_shared<PoolRegistry>(&scenario);
            let coin_a = coin::mint_for_testing<USDC>(200000, ts::ctx(&mut scenario));
            let coin_b = coin::mint_for_testing<USDT>(200000, ts::ctx(&mut scenario));
            let (pos, ref_a, ref_b) = factory::create_pool<USDC, USDT>(
                &mut registry,
                factory::fee_tier_medium(),
                0,
                coin_a,
                coin_b,
                ts::ctx(&mut scenario)
            );
            coin::burn_for_testing(ref_a);
            coin::burn_for_testing(ref_b);
            sui::transfer::public_transfer(pos, ADMIN);
            ts::return_shared(registry);
        };
        
        ts::next_tx(&mut scenario, LP1);
        {
            let pool = ts::take_shared<LiquidityPool<USDC, USDT>>(&scenario);
            
            let usdc = coin::mint_for_testing<USDC>(1000000, ts::ctx(&mut scenario));
            let usdt = coin::mint_for_testing<USDT>(1000000, ts::ctx(&mut scenario));
            
            // ADD LIQUIDITY - Main operation to benchmark
            let (position, refund_a, refund_b) = pool::add_liquidity(
                &mut pool,
                usdc,
                usdt,
                0,
                ts::ctx(&mut scenario)
            );
            
            coin::burn_for_testing(refund_a);
            coin::burn_for_testing(refund_b);
            ts::return_shared(pool);
            sui::transfer::public_transfer(position, LP1);
        };
        
        ts::end(scenario);
    }

    /// Benchmark: Add subsequent liquidity
    #[test]
    fun benchmark_add_subsequent_liquidity() {
        let scenario = ts::begin(ADMIN);
        
        // Setup pool with initial liquidity
        factory::test_init(ts::ctx(&mut scenario));
        
        ts::next_tx(&mut scenario, ADMIN);
        {
            let registry = ts::take_shared<PoolRegistry>(&scenario);
            let coin_a = coin::mint_for_testing<USDC>(200000, ts::ctx(&mut scenario));
            let coin_b = coin::mint_for_testing<USDT>(200000, ts::ctx(&mut scenario));
            let (pos, ref_a, ref_b) = factory::create_pool<USDC, USDT>(
                &mut registry,
                factory::fee_tier_medium(),
                0,
                coin_a,
                coin_b,
                ts::ctx(&mut scenario)
            );
            coin::burn_for_testing(ref_a);
            coin::burn_for_testing(ref_b);
            sui::transfer::public_transfer(pos, ADMIN);
            ts::return_shared(registry);
        };
        
        ts::next_tx(&mut scenario, LP1);
        {
            let pool = ts::take_shared<LiquidityPool<USDC, USDT>>(&scenario);
            let usdc = coin::mint_for_testing<USDC>(1000000, ts::ctx(&mut scenario));
            let usdt = coin::mint_for_testing<USDT>(1000000, ts::ctx(&mut scenario));
            let (pos1, r_a, r_b) = pool::add_liquidity(&mut pool, usdc, usdt, 0, ts::ctx(&mut scenario));
            coin::burn_for_testing(r_a);
            coin::burn_for_testing(r_b);
            ts::return_shared(pool);
            sui::transfer::public_transfer(pos1, LP1);
        };
        
        // Benchmark subsequent add
        ts::next_tx(&mut scenario, LP1);
        {
            let pool = ts::take_shared<LiquidityPool<USDC, USDT>>(&scenario);
            
            let usdc = coin::mint_for_testing<USDC>(500000, ts::ctx(&mut scenario));
            let usdt = coin::mint_for_testing<USDT>(500000, ts::ctx(&mut scenario));
            
            // ADD LIQUIDITY (SUBSEQUENT) - Main operation to benchmark
            let (position, refund_a, refund_b) = pool::add_liquidity(
                &mut pool,
                usdc,
                usdt,
                0,
                ts::ctx(&mut scenario)
            );
            
            coin::burn_for_testing(refund_a);
            coin::burn_for_testing(refund_b);
            ts::return_shared(pool);
            sui::transfer::public_transfer(position, LP1);
        };
        
        ts::end(scenario);
    }

    /// Benchmark: Swap operation
    #[test]
    fun benchmark_swap() {
        let scenario = ts::begin(ADMIN);
        
        // Setup pool with liquidity
        factory::test_init(ts::ctx(&mut scenario));
        
        ts::next_tx(&mut scenario, ADMIN);
        {
            let registry = ts::take_shared<PoolRegistry>(&scenario);
            let coin_a = coin::mint_for_testing<USDC>(200000, ts::ctx(&mut scenario));
            let coin_b = coin::mint_for_testing<USDT>(200000, ts::ctx(&mut scenario));
            let (pos, ref_a, ref_b) = factory::create_pool<USDC, USDT>(
                &mut registry,
                factory::fee_tier_medium(),
                0,
                coin_a,
                coin_b,
                ts::ctx(&mut scenario)
            );
            coin::burn_for_testing(ref_a);
            coin::burn_for_testing(ref_b);
            sui::transfer::public_transfer(pos, ADMIN);
            ts::return_shared(registry);
        };
        
        ts::next_tx(&mut scenario, LP1);
        {
            let pool = ts::take_shared<LiquidityPool<USDC, USDT>>(&scenario);
            let usdc = coin::mint_for_testing<USDC>(1000000, ts::ctx(&mut scenario));
            let usdt = coin::mint_for_testing<USDT>(1000000, ts::ctx(&mut scenario));
            let (pos, r_a, r_b) = pool::add_liquidity(&mut pool, usdc, usdt, 0, ts::ctx(&mut scenario));
            coin::burn_for_testing(r_a);
            coin::burn_for_testing(r_b);
            ts::return_shared(pool);
            sui::transfer::public_transfer(pos, LP1);
        };
        
        // Setup clock
        ts::next_tx(&mut scenario, ADMIN);
        let clock = clock::create_for_testing(ts::ctx(&mut scenario));
        clock::share_for_testing(clock);
        
        // Benchmark swap
        ts::next_tx(&mut scenario, ADMIN);
        {
            let pool = ts::take_shared<LiquidityPool<USDC, USDT>>(&scenario);
            let clock = ts::take_shared<Clock>(&scenario);
            
            let usdc_in = coin::mint_for_testing<USDC>(10000, ts::ctx(&mut scenario));
            
            // SWAP - Main operation to benchmark
            let usdt_out = pool::swap_a_to_b(
                &mut pool,
                usdc_in,
                0,
                option::none(),
                &clock,
                1000000000000,
                ts::ctx(&mut scenario)
            );
            
            coin::burn_for_testing(usdt_out);
            ts::return_shared(pool);
            ts::return_shared(clock);
        };
        
        ts::end(scenario);
    }

    /// Benchmark: Remove liquidity
    #[test]
    fun benchmark_remove_liquidity() {
        let scenario = ts::begin(ADMIN);
        
        // Setup pool with liquidity
        factory::test_init(ts::ctx(&mut scenario));
        
        ts::next_tx(&mut scenario, ADMIN);
        {
            let registry = ts::take_shared<PoolRegistry>(&scenario);
            let coin_a = coin::mint_for_testing<USDC>(200000, ts::ctx(&mut scenario));
            let coin_b = coin::mint_for_testing<USDT>(200000, ts::ctx(&mut scenario));
            let (pos, ref_a, ref_b) = factory::create_pool<USDC, USDT>(
                &mut registry,
                factory::fee_tier_medium(),
                0,
                coin_a,
                coin_b,
                ts::ctx(&mut scenario)
            );
            coin::burn_for_testing(ref_a);
            coin::burn_for_testing(ref_b);
            sui::transfer::public_transfer(pos, ADMIN);
            ts::return_shared(registry);
        };
        
        ts::next_tx(&mut scenario, LP1);
        {
            let pool = ts::take_shared<LiquidityPool<USDC, USDT>>(&scenario);
            let usdc = coin::mint_for_testing<USDC>(1000000, ts::ctx(&mut scenario));
            let usdt = coin::mint_for_testing<USDT>(1000000, ts::ctx(&mut scenario));
            let (pos, r_a, r_b) = pool::add_liquidity(&mut pool, usdc, usdt, 0, ts::ctx(&mut scenario));
            coin::burn_for_testing(r_a);
            coin::burn_for_testing(r_b);
            ts::return_shared(pool);
            sui::transfer::public_transfer(pos, LP1);
        };
        
        // Benchmark remove
        ts::next_tx(&mut scenario, LP1);
        {
            let pool = ts::take_shared<LiquidityPool<USDC, USDT>>(&scenario);
            let position = ts::take_from_sender<LPPosition>(&scenario);
            
            // REMOVE LIQUIDITY - Main operation to benchmark
            let (usdc_out, usdt_out) = pool::remove_liquidity(
                &mut pool,
                position,
                0,
                0,
                ts::ctx(&mut scenario)
            );
            
            coin::burn_for_testing(usdc_out);
            coin::burn_for_testing(usdt_out);
            ts::return_shared(pool);
        };
        
        ts::end(scenario);
    }

    /// Benchmark: Claim fees
    #[test]
    fun benchmark_claim_fees() {
        let scenario = ts::begin(ADMIN);
        
        // Setup pool with liquidity and generate some fees
        factory::test_init(ts::ctx(&mut scenario));
        
        ts::next_tx(&mut scenario, ADMIN);
        {
            let registry = ts::take_shared<PoolRegistry>(&scenario);
            let coin_a = coin::mint_for_testing<USDC>(200000, ts::ctx(&mut scenario));
            let coin_b = coin::mint_for_testing<USDT>(200000, ts::ctx(&mut scenario));
            let (pos, ref_a, ref_b) = factory::create_pool<USDC, USDT>(
                &mut registry,
                factory::fee_tier_medium(),
                0,
                coin_a,
                coin_b,
                ts::ctx(&mut scenario)
            );
            coin::burn_for_testing(ref_a);
            coin::burn_for_testing(ref_b);
            sui::transfer::public_transfer(pos, ADMIN);
            ts::return_shared(registry);
        };
        
        ts::next_tx(&mut scenario, LP1);
        {
            let pool = ts::take_shared<LiquidityPool<USDC, USDT>>(&scenario);
            let usdc = coin::mint_for_testing<USDC>(1000000, ts::ctx(&mut scenario));
            let usdt = coin::mint_for_testing<USDT>(1000000, ts::ctx(&mut scenario));
            let (pos, r_a, r_b) = pool::add_liquidity(&mut pool, usdc, usdt, 0, ts::ctx(&mut scenario));
            coin::burn_for_testing(r_a);
            coin::burn_for_testing(r_b);
            ts::return_shared(pool);
            sui::transfer::public_transfer(pos, LP1);
        };
        
        // Setup clock
        ts::next_tx(&mut scenario, ADMIN);
        let clock = clock::create_for_testing(ts::ctx(&mut scenario));
        clock::share_for_testing(clock);
        
        // Generate fees via swap
        ts::next_tx(&mut scenario, ADMIN);
        {
            let pool = ts::take_shared<LiquidityPool<USDC, USDT>>(&scenario);
            let clock = ts::take_shared<Clock>(&scenario);
            let usdc_in = coin::mint_for_testing<USDC>(10000, ts::ctx(&mut scenario));
            let usdt_out = pool::swap_a_to_b(&mut pool, usdc_in, 0, option::none(), &clock, 1000000000000, ts::ctx(&mut scenario));
            coin::burn_for_testing(usdt_out);
            ts::return_shared(pool);
            ts::return_shared(clock);
        };
        
        // Benchmark claim fees
        ts::next_tx(&mut scenario, LP1);
        {
            let pool = ts::take_shared<LiquidityPool<USDC, USDT>>(&scenario);
            let position = ts::take_from_sender<LPPosition>(&scenario);
            
            // CLAIM FEES - Main operation to benchmark
            let (fee_a, fee_b) = fee_distributor::claim_fees_simple(
                &mut pool,
                &mut position,
                ts::ctx(&mut scenario)
            );
            
            coin::burn_for_testing(fee_a);
            coin::burn_for_testing(fee_b);
            ts::return_shared(pool);
            sui::transfer::public_transfer(position, LP1);
        };
        
        ts::end(scenario);
    }

    /// Benchmark: Stable swap operation
    #[test]
    fun benchmark_stable_swap() {
        let scenario = ts::begin(ADMIN);
        
        // Setup stable pool
        factory::test_init(ts::ctx(&mut scenario));
        
        ts::next_tx(&mut scenario, ALICE);
        {
            let clock_val = clock::create_for_testing(ts::ctx(&mut scenario));
            let registry = ts::take_shared<PoolRegistry>(&scenario);
            let usdc = coin::mint_for_testing<USDC>(10_000_000, ts::ctx(&mut scenario));
            let usdt = coin::mint_for_testing<USDT>(10_000_000, ts::ctx(&mut scenario));
            
            let (pos, ref_a, ref_b) = factory::create_stable_pool<USDC, USDT>(
                &mut registry,
                factory::fee_tier_low(), // 0.05% for stables
                500,
                usdc,
                usdt,
                &clock_val, ts::ctx(&mut scenario)
            );
            coin::burn_for_testing(ref_a);
            coin::burn_for_testing(ref_b);
            sui::transfer::public_transfer(pos, ADMIN);
            ts::return_shared(registry);
        };
        
        ts::next_tx(&mut scenario, LP1);
        {
            let pool = ts::take_shared<StableSwapPool<USDC, USDT>>(&scenario);
            let usdc = coin::mint_for_testing<USDC>(1000000, ts::ctx(&mut scenario));
            let usdt = coin::mint_for_testing<USDT>(1000000, ts::ctx(&mut scenario));
            let (pos, r_a, r_b) = stable_pool::add_liquidity(&mut pool, usdc, usdt, 0, &clock_val, 18446744073709551615, ts::ctx(&mut scenario));
            coin::burn_for_testing(r_a);
            coin::burn_for_testing(r_b);
            ts::return_shared(pool);
            sui::transfer::public_transfer(pos, LP1);
        };
        
        // Setup clock
        ts::next_tx(&mut scenario, ADMIN);
        let clock = clock::create_for_testing(ts::ctx(&mut scenario));
        clock::share_for_testing(clock);
        
        // Benchmark stable swap
        ts::next_tx(&mut scenario, ADMIN);
        {
            let pool = ts::take_shared<StableSwapPool<USDC, USDT>>(&scenario);
            let clock = ts::take_shared<Clock>(&scenario);
            
            let usdc_in = coin::mint_for_testing<USDC>(10000, ts::ctx(&mut scenario));
            
            // STABLE SWAP - Main operation to benchmark
            let usdt_out = stable_pool::swap_a_to_b(
                &mut pool,
                usdc_in,
                0,
                option::none(),
                &clock,
                1000000000000,
                ts::ctx(&mut scenario)
            );
            
            coin::burn_for_testing(usdt_out);
            ts::return_shared(pool);
            ts::return_shared(clock);
        };
        
        ts::end(scenario);
    }
}
